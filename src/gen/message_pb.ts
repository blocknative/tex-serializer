// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file message.proto (syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message WebSocketResponse
 */
export class WebSocketResponse extends Message<WebSocketResponse> {
  /**
   * @generated from field: required string status = 1;
   */
  status?: string;

  /**
   * @generated from field: required string feed = 2;
   */
  feed?: string;

  /**
   * @generated from field: optional Data data = 3;
   */
  data?: Data;

  /**
   * @generated from field: optional Error error = 4;
   */
  error?: Error;

  constructor(data?: PartialMessage<WebSocketResponse>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "WebSocketResponse";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "feed", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "data", kind: "message", T: Data, opt: true },
    { no: 4, name: "error", kind: "message", T: Error, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebSocketResponse {
    return new WebSocketResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebSocketResponse {
    return new WebSocketResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebSocketResponse {
    return new WebSocketResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WebSocketResponse | PlainMessage<WebSocketResponse> | undefined, b: WebSocketResponse | PlainMessage<WebSocketResponse> | undefined): boolean {
    return proto2.util.equals(WebSocketResponse, a, b);
  }
}

/**
 * @generated from message PendingTx
 */
export class PendingTx extends Message<PendingTx> {
  /**
   * @generated from field: required string h = 1;
   */
  h?: string;

  /**
   * @generated from field: required float g = 2;
   */
  g?: number;

  /**
   * @generated from field: required string to = 3;
   */
  to?: string;

  /**
   * @generated from field: required google.protobuf.Timestamp t = 4;
   */
  t?: Timestamp;

  /**
   * @generated from field: optional string f = 5;
   */
  f?: string;

  /**
   * @generated from field: optional int32 n = 6;
   */
  n?: number;

  constructor(data?: PartialMessage<PendingTx>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "PendingTx";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "h", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "g", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "t", kind: "message", T: Timestamp },
    { no: 5, name: "f", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "n", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingTx {
    return new PendingTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingTx {
    return new PendingTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingTx {
    return new PendingTx().fromJsonString(jsonString, options);
  }

  static equals(a: PendingTx | PlainMessage<PendingTx> | undefined, b: PendingTx | PlainMessage<PendingTx> | undefined): boolean {
    return proto2.util.equals(PendingTx, a, b);
  }
}

/**
 * @generated from message DroppedTx
 */
export class DroppedTx extends Message<DroppedTx> {
  /**
   * @generated from field: required string h = 1;
   */
  h?: string;

  /**
   * @generated from field: required bool d = 2;
   */
  d?: boolean;

  constructor(data?: PartialMessage<DroppedTx>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "DroppedTx";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "h", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "d", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DroppedTx {
    return new DroppedTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DroppedTx {
    return new DroppedTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DroppedTx {
    return new DroppedTx().fromJsonString(jsonString, options);
  }

  static equals(a: DroppedTx | PlainMessage<DroppedTx> | undefined, b: DroppedTx | PlainMessage<DroppedTx> | undefined): boolean {
    return proto2.util.equals(DroppedTx, a, b);
  }
}

/**
 * @generated from message MempoolTx
 */
export class MempoolTx extends Message<MempoolTx> {
  /**
   * @generated from oneof MempoolTx.tx
   */
  tx: {
    /**
     * @generated from field: PendingTx pending = 1;
     */
    value: PendingTx;
    case: "pending";
  } | {
    /**
     * @generated from field: DroppedTx dropped = 2;
     */
    value: DroppedTx;
    case: "dropped";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MempoolTx>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "MempoolTx";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "pending", kind: "message", T: PendingTx, oneof: "tx" },
    { no: 2, name: "dropped", kind: "message", T: DroppedTx, oneof: "tx" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MempoolTx {
    return new MempoolTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MempoolTx {
    return new MempoolTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MempoolTx {
    return new MempoolTx().fromJsonString(jsonString, options);
  }

  static equals(a: MempoolTx | PlainMessage<MempoolTx> | undefined, b: MempoolTx | PlainMessage<MempoolTx> | undefined): boolean {
    return proto2.util.equals(MempoolTx, a, b);
  }
}

/**
 * @generated from message BlockTx
 */
export class BlockTx extends Message<BlockTx> {
  /**
   * @generated from field: required string h = 1;
   */
  h?: string;

  /**
   * @generated from field: required int32 i = 2;
   */
  i?: number;

  /**
   * @generated from field: required float g = 3;
   */
  g?: number;

  /**
   * @generated from field: required string to = 4;
   */
  to?: string;

  /**
   * @generated from field: required int32 gu = 5;
   */
  gu?: number;

  /**
   * @generated from field: required string s = 6;
   */
  s?: string;

  constructor(data?: PartialMessage<BlockTx>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "BlockTx";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "h", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "i", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "g", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gu", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "s", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockTx {
    return new BlockTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockTx {
    return new BlockTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockTx {
    return new BlockTx().fromJsonString(jsonString, options);
  }

  static equals(a: BlockTx | PlainMessage<BlockTx> | undefined, b: BlockTx | PlainMessage<BlockTx> | undefined): boolean {
    return proto2.util.equals(BlockTx, a, b);
  }
}

/**
 * @generated from message Data
 */
export class Data extends Message<Data> {
  /**
   * @generated from oneof Data.data
   */
  data: {
    /**
     * @generated from field: BlockData block = 1;
     */
    value: BlockData;
    case: "block";
  } | {
    /**
     * @generated from field: MempoolData mempool = 2;
     */
    value: MempoolData;
    case: "mempool";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Data>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "Data";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "block", kind: "message", T: BlockData, oneof: "data" },
    { no: 2, name: "mempool", kind: "message", T: MempoolData, oneof: "data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Data {
    return new Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJsonString(jsonString, options);
  }

  static equals(a: Data | PlainMessage<Data> | undefined, b: Data | PlainMessage<Data> | undefined): boolean {
    return proto2.util.equals(Data, a, b);
  }
}

/**
 * @generated from message MempoolData
 */
export class MempoolData extends Message<MempoolData> {
  /**
   * @generated from field: required string chainId = 1;
   */
  chainId?: string;

  /**
   * @generated from field: repeated MempoolTx txs = 2;
   */
  txs: MempoolTx[] = [];

  constructor(data?: PartialMessage<MempoolData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "MempoolData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "chainId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "txs", kind: "message", T: MempoolTx, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MempoolData {
    return new MempoolData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MempoolData {
    return new MempoolData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MempoolData {
    return new MempoolData().fromJsonString(jsonString, options);
  }

  static equals(a: MempoolData | PlainMessage<MempoolData> | undefined, b: MempoolData | PlainMessage<MempoolData> | undefined): boolean {
    return proto2.util.equals(MempoolData, a, b);
  }
}

/**
 * @generated from message BlockData
 */
export class BlockData extends Message<BlockData> {
  /**
   * @generated from field: required string chainId = 1;
   */
  chainId?: string;

  /**
   * @generated from field: required int32 height = 2;
   */
  height?: number;

  /**
   * @generated from field: required string hash = 3;
   */
  hash?: string;

  /**
   * @generated from field: required int32 timestamp = 4;
   */
  timestamp?: number;

  /**
   * @generated from field: required int32 txnCount = 5;
   */
  txnCount?: number;

  /**
   * @generated from field: repeated BlockTx txs = 6;
   */
  txs: BlockTx[] = [];

  constructor(data?: PartialMessage<BlockData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "BlockData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "chainId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "height", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "timestamp", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "txnCount", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "txs", kind: "message", T: BlockTx, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockData {
    return new BlockData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockData {
    return new BlockData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockData {
    return new BlockData().fromJsonString(jsonString, options);
  }

  static equals(a: BlockData | PlainMessage<BlockData> | undefined, b: BlockData | PlainMessage<BlockData> | undefined): boolean {
    return proto2.util.equals(BlockData, a, b);
  }
}

/**
 * @generated from message UnsubscribeData
 */
export class UnsubscribeData extends Message<UnsubscribeData> {
  /**
   * @generated from field: required string chainId = 1;
   */
  chainId?: string;

  constructor(data?: PartialMessage<UnsubscribeData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "UnsubscribeData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "chainId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnsubscribeData {
    return new UnsubscribeData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnsubscribeData {
    return new UnsubscribeData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnsubscribeData {
    return new UnsubscribeData().fromJsonString(jsonString, options);
  }

  static equals(a: UnsubscribeData | PlainMessage<UnsubscribeData> | undefined, b: UnsubscribeData | PlainMessage<UnsubscribeData> | undefined): boolean {
    return proto2.util.equals(UnsubscribeData, a, b);
  }
}

/**
 * @generated from message Error
 */
export class Error extends Message<Error> {
  /**
   * @generated from field: required int32 code = 1;
   */
  code?: number;

  /**
   * @generated from field: required string message = 2;
   */
  message?: string;

  constructor(data?: PartialMessage<Error>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "Error";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto2.util.equals(Error, a, b);
  }
}

